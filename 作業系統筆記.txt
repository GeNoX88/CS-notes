micro kernel微核心把kernel的功能與程式碼最小化，system service也在它之外，服務、應用之間的data交換必須通過kernel做IPC(inter-process communication)
monolithic kernel單核心把所有system service整合進kernel，並且裡面全都是privileged instructions
Deadlock意味著有兩個以上的processes或threads等運算單元都在等待彼此執行完成並釋出資源, 卻沒有人能先完成, 造成所有人停擺的現象
Deadlock的發生有四個條件:                                 
    -no preemption
    -hold and wait
    -mutual exclusion
    -circular waiting

Part One Overview
Chapter 1 Introduction

interrupt在現代OS中被廣泛用來處理非同步事件
電腦開機後跑的第一支程式是個bootstrap program，放在electrically erasable programmable read-only memory(EEPROM)
word是給定之電腦架構的自然資料單位，可能有一或更多個byte，電腦一次處理一個word而不是一個byte
1TB(terabyte)=1024^4 bytes, 1 PB(petabyte)=1024^5 bytes
電腦製造業會四捨五入的說1MB是一百萬bytes，1TB是十億bytes
networking測量比較例外，是以bit為單位，因為一次移動1 bit的資料
von Neumann architecture的系統下，一個典型的instruction-execution cycle會先fetch一個instruction進instruction register再fetch operands進來執行
blu-ray (藍光光碟)是以藍色雷射光束來進行讀寫作業，能儲存高品質、高容量的資料
secondary storage還有更下一層叫tertiary storage(第三儲存)，如optical disk, magnetic tapes等
NVM(nonvolatile memory)介於memory和hard-disk drive之間，常見的NVM device為flash memory，在行動裝置中很受歡迎
電子式NVS((nonvolatile storage)有flash memory, FRAM, NRAM, and SSD等
OS很大一部分code是貢獻在管理I/O這件事上
NVS I/O device透過DMA(direct memory access)跟memory傳送資料，而不需要CPU的intervention，它會設好buffers, pointers, counters，資料一次傳一整個block，然後才產生一個interrupt
一些高端系統使用switch架構而非bus架構，在這些系統上，多個components可以跟其他components對話concurrently，而不用在一個shared bus上競爭cycle
core是處理器中的component用來execute instructions和registers，single-processor(即單核單處理器) system其實包含很多special-purpose processors，如disk, keyboard, and graphics controllers等，它們都只run a limited instruction set 而不run processes，他們有些會受OS調度
最普遍的multiprocessor system使用symmetric multiprocessing(SMP)，each peer processor(core)執行所有任務包括OS functions跟user processes
multiprocessor的定義現在擴展到包含multicore systems，其中多個cores reside on a single chip，多核單處理器可以比單核多處理器更有效率，因為on-chip communication就是快
多核處理器中最靠近一個core的register的cache為L1 cache(較小、快並且是local的)，連接到L2(和L3) cache(較大、慢且是shared cache)
CPU一旦變多，system bus就變成效能bottleneck，所以另一種方法是所有CPU用shared system interconnect溝通，但他們有各自的local memory，此法名為NUMA(non-uniform memory access)，靠OS排程讓CPU們盡量只需用到自己的memory裡的東西，這種NUMA系統能容量大量處理器，在server跟高效能計算系統上很熱門
blade server是指一個系統包含多個processors, I/O, networking board套組，套組各自獨立且跑著自己的OS
clustered system由多個獨立的系統或nodes組成，每個node都是multicore system，此種系統是loosely coupled的，通常的定義是系統中的電腦會共用storage並由 a local-area network (LAN)或更快的interconnect像是InfiniBand連線
，它提供high-availability service，就算其中一個系統掛了也能繼續運作，nodes會互相監控，如果運作的機器掛了，監控他的node會用他的storage並在自己這個node重啟應用
對稱vs非對稱 clustering分別是 hosts都會跑app跟互相監控 vs 一個host跑app，另一個做hot-standby並監視他
parallelization是把一個program拆成數個部分在不同的core或電腦去跑
parallel clusters允許多個hosts使用共享的storage，那就要搭配distributed lock manager(DLM)去控制database的access跟locking
storage-area networks(SANs)允許眾多系統 attach to a pool of storage，那麼app的運作就不限定要哪個host，使用中的掛了就找其他host代替，大大提升效能跟可靠度
開機後kernel會提供system services，其中一些變成system daemons(常駐程式) e.g. Linux的第一支系統程式是"systemd"，它會啟動許多daemons
software產生的interrupts叫trap(or exception)，例如某些errors：除以零或非法的memory access
一個multiprogrammed system中，一支執行中的程式稱為process，最終process需要等待像是I/O等操作完成，在non-multiprogrammed system中CPU會idle而multiprogrammed system永遠不會idle而是暫時換到其他process來跑
multitasking是multiprogramming的擴展，意思是CPU跑多個processes以外，還切換得很頻繁，所以response time很短
CPU scheduling用來安排process的執行順序
multiprogramming and multitasking systems 必須提供file system、synchronization跟communication機制，還要確保processes不會發生deadlock
大部分電腦都有專用硬體來區分各種execution的mode，此硬體中的mode bit會指示當前任務的mode，0是kernel mode，1是user mode
最少會需要兩種mode的operation：user mode跟kernel mode(supervisor mode, system mode, or privileged mode)
當user application發出system call(trap的一種)來請求system service，系統會從user mode切換到kernel mode來做，做完後回到user process
如果試圖在user mode做privileged instruction，hardware不會執行而是traps it to the OS
privileged instructions舉例像是I/O control, timer management, and interrupt management等 
the instruction to switch to kernel mode是被特別處理的(所以不是privileged)，有時透過trap，有時透過unique instruction
Intel processors有四個protection rings，ring 0是kernel mode、ring 3是user mode、ring 1, ring 2是for各種OS services但很少用到
ARMv8系統有7個modes
支援virtualization的CPU常常有額外的一個mode來指出系統是不是在用virtual machine manager(VMM)，此mode權限大於user process少於kernel
system call這個trap通常可以用"trap"這instruction來實現，有些系統是叫 "syscall"
interrupt handler又叫interrupt service routine(ISR)，其pointer位於interrupt vector，vector中每個都是一個list
kernel根據system call的參數和額外資訊(在register, stack或memory中)來給予OS中對應的service
當program error產生，OS必須不正常地終止程序，這情況handled by the same code as 一個user-requested abnormal termination，error message產生並且程序的memory可能會被dump，back up(備份)進file
timer會週期性的發出interrupt，週期可以是固定也可以是可變(variable timer)，後者包含fixed-rate clock跟counter
process中有幾個threads就要有幾個program counters
a process is the unit of work in a system，processes can potentially execute concurrently-by multiplexing on a single CPU core-or in parallel across multiple CPU cores
講到process，OS負責(1)建立跟刪除user/system processes (2)CPU的process和threads排程 (3)processes的suspending跟resuming (4)提供process synchronization機制 (5)提供process communication機制
講到memory，OS負責(1)追蹤有在使用的memory以及被哪個process使用(2)分配跟釋放memory(3)決定哪個process(或process的部分)和data要move in and out of memory
一個file代表程式(包含source和object forms)和data之集合，data可以是numeric, alphabetic, alphanumeric, binary的，file可以是free form(e.g. text file)或formatted rigidly(fixed fields such as mp3等)
講到file，OS負責(1)增刪檔案(2)增刪目錄來組織檔案(3)支援用來操作檔案跟目錄的原語(primitive)(4)mapping files onto mass storage(5)備份檔案到non volatile 儲存media
講到mass-storage，OS負責次要存儲的(1)mounting and unmounting (2)free-space管理 (3)storage allocation (4)disk scheduling (5)partitioning (6)protection
register是種programable internal cache，register-allocation & register-replacement algorithm由compiler決定，cache的使用由hardware決定
cache coherency是說不同CPU的local cache改了變數的值，其餘的CPU的local cache要能立刻更新此值
OS的一個目的是對user hide the peculiarities(古怪) of 特定硬體裝置，例如在UNIX中，I/O devices的I/O subsystem能對OS隱藏自己，只有device driver知道這device的特別
I/O subsystem由下列組成 (1) 一個memory-management component 包含buffering, caching, and spooling (2) a general device-driver interface (3) derivers for specific hardware devices
virtualization把硬體抽象化成多個運行環境，讓OS能像app一樣，一台電腦上數個OS run concurrently
virtualization是emulation(仿真)的一種，emulation也包括在software上模擬電腦硬體，例如Apple的emulation facility-Rosetta允許app被編譯成IBM CPU才看得懂的指令，卻跑在Intel x86 CPU上
Windows作為host OS，我們在上面跑VMware這樣的app，VMware是種virtual machine manager(VMM)，它會跑一個guest OS跟管理他們資源的使用，VMware還可以多開
TCP/IP是最常見的network protocol，network有好幾種 (1)local-area network(LAN) 在建築或房間內連結數台電腦 (2)wide-area network(WAN) 跨越建築、城市甚至國家的連線 (3)metropolian-area network(MAN)一個城市內連結數棟建築物 (4)personal-area network(PAN)利用藍牙(802.11標準)、紅外線實現手機、電腦、耳機之間的有線和無線通訊
kernel常用的資料結構有：list, stack, queue, tree(像Linux的CPU scheduling就有用到red-black tree), hash function&hash map, bitmap等
client-server system是種分散式系統，其中又分兩種(1)compute-server system server會執行客戶的請求，比如傳回計算結果或是server資料庫裡的資料(2)file-serve system提供client一個檔案系統介面，來增刪查改檔案，e.g. web server
peer-to-peer(P2P) system是對等、去中心化的分散式系統，每個node既可以是client也可以是server，node要加入此網路，要馬使用centralized lookup service去尋找提供desired service的node，要馬自己找，broadcast request直到有node respond我(discovery protocol)
cloud computing是virtualization的一種延伸，例如Amazon Elastic Compute Cloud(ec2) 有數千個server、數百萬個虛擬機與petabytes的存儲，藉由cloud customer interface及cloud managment service提供給所有付費用戶使用
常見的三種cloud computing：Software/Platform/Infrastructrue as a service(SaaS/PaaS/IaaS)
embedded system是最prevalent(普遍)的電腦，通常用來完成特殊任務，有些跑著標準的OS例如Linux，有些跑著特別的嵌入式OS，有些則是硬體裝置裡只有application-specific integrated circuits(ASICs)來完成任務也沒有OS
embedded system幾乎都是real-time operating systems，也就是處理器操作或資料傳送有明確的時間限制，一旦超過那系統就會失效
free OS跟open-source OS都有公開的源代碼，但後者不一定都是free(免費、自由)的，GNU/Linux是最有名的開源OS，Windows則是最有名的closed-source OS，是種所有權軟體，Apple macOS則混合兩種特性，它包含開源的Darwin核心，但也包含閉源部分
Richard Stallman發起一個free, UNIX-compatible的OS稱為GNU，間接催生了GNU/Linux作業系統的成功
BSD UNIX不像Linux，是開源在"subversion"這個版控系統，像macOS中的Darwin核心就是基於BSD UNIX的

Chapter 2 Operating-System Structures

OS services中對user友善的functions有：user interface, program execution, file-system manipulation, inter-process communication(IPC), error dectction
OS services中以提升系統效率的functions有：resource allocation, logging, protection and security
command intepreter(shell)有兩種：看得懂command並且jump to a section of its code，設置參數與做system call，另一種看不懂command，而是用command來指認一個檔案放進memory直接執行(UNIX就是這種，rm file.txt其實是去執行一個叫rm的檔案)，這種interpreter小，若要加新command也方便
iPad和iPhone都用名為Springboard的觸控螢幕界面
OS經常每秒執行數千個system call
最常見的系統API有：Windows API (Windows), POSIX API (UNIX, Linux, macOS等), Java API(Java virtual machine)
system-call interface是種API，e.g. open()，會幫忙invoke位於底層的實際system call，一般來說每種system call會對應一個數字，system-call interface會maintain一個表，裡面index就是那些system call的數字
real-time environment(RTE)是軟體、編譯器、interpreter(直譯器)、library和loader的組合
system call需要的參數會以純數值(少)或memory address of block(多，超過五個參數時 in Linux)傳入register
如果程式產生error或trap，有時memory 會被dump到disk存成dmp檔，這可以用一個系統程式叫debugger來檢視跟除錯。
types of system call: (1)process control, (2)file management, (3)device management, (4)information maintenance, (5)communication, protection
(1)create, terminate process. load, execute. get process attributes, set process attributes. wait event, signal event. allocate and free memory.
(2)create, delete file. open, close. read, write, reposition. get file attributes, set file attributes
(3)request device, release device. read, write, reposition. get device attributes, set device attributes. logically attach or detach devices
(4)get time or date, set time or date. get system data, set system data. get process, file, or device attributes. set process, file, or device attributes.
(5)create, delete communication connection. send, receive messages. transfer status info. attach or detach remote devices.
(6)get file permissions. set file permissions.
Arduino的flash memory用來存編譯好的程式(也就是sketch)，boot loader會把一個sketch抓進memory給mcu執行，Arduino是single-tasking
file management中的reposition()功能為rewind or skip to the end of the file, for example
很多處理器(甚至microprocessor)都有個mode叫single step，它讓a trap is executed by the CPU after every instruction，那trap則經常是caught by a debugger
有兩種interprocess communication：(1)message-passing model (2)shared-memory
(1)messages直接或間接透過a common mailbox做交換
(2)processes間彼此允許的情況下，使用同一塊內存
system services(又叫system utilities)包含以下數種(1)file management (2)status information (3)file modification (4)program loading and execution (5)communication (6)background services
(2)有些系統支援registry，那是用來存放configuration information的
(4)程式必須被load進memory才能執行，所以系統可能需要提供absolute loader, relocatable loader, lindage editor, and overlay loader
(5)常駐的system-program processes叫services, subsystems, or daemons. e.g. network daemon, process scheduler, system monitoring services
除了系統程式，大部分OS也提供application programs包括web browser, word processors and text formatters, spreadsheets, database system, compilers, plotting and statistical-analysis packages, and game
程式的執行流程：source program被compile成object file，存進disk，linker把它以及相關的object files, libraries都link起來變成executable，執行這程式時，loader會把它抓進memory
大多系統支援dynamically linked libraries(DLLs)，讓libraries在程式剛load甚至執行時才被link進來，避免libraries早早link進來卻始終沒用到的情況，省下大量memory
Object files及executable files一般有標準格式，包含機器碼和一個symbol table內含functions, variables的metadata，for UNIX and Linux，此格式稱為ELF(Executable and Linkable Format)，Windows use Portable Executable(PE) format, and macOS use Mach-O format
App可藉由下列三種方式達成在多種OS執行：(1)用直譯式語言寫，使用相容於多種OS的interpreter執行，但interpreter可能只提供每個OS的部分功能 (2)用vm的語言寫， e.g. Java的RTE包含loader, byte-code verifier以及其他能把Java app load進vm的components，RTE被ported到眾多OS，缺點跟(1)一樣 (3)app用標準語言或API寫，但我得port他到每個OS，而這很花時間，要做很多測試跟debugging e.g. POSIX API
app跨OS的其它挑戰在於系統底層：(1)每個OS對於header, instructions, variables有自己的layout(2)CPUs的instruction sets各不相同(3)system call的參數順序、app invoke它的方式、它們的號碼、傳回的結果因OS而異
一些approaches解決了定址問題，還剩架構差異問題，Linux和UNIX採用ELF for binary executables，此法沒綁定在任何電腦架構，所以不保證能在任何硬體平台上跑
在architecture level，application binary interface(ABI)被用來定義binary code中的不同components面對給定OS跟架構的方式，它specify low-level details諸如address width, 傳參給system call的方式、stack在run-time如何組織，system libraries的binary format，data type的size等，ABI就像架構層級的API
如果一個binary executable依據一個特定的ABI被編譯和link，那他就能在各種支援那ABI的OS執行，不過ABI是針對一種架構的，所以沒辦法做到跨平台的相容性
最simple的系統結構monolithic structure(known as tightly coupled system)：把kernel的所有功能全放在單一的binary file，在單一的address space執行，像是original UNIX OS分成兩部分，包含一系列interfaces、device drivers的kernel，以及system programs，Linux也是此種結構，它的app一般用"glibc"標準C庫這樣的system call interface跟kernel溝通
Linux的分層結構如下：application -> system-call interface -> kernel(file systems, CPU scheduler, networks, memory manager, block devices, character devices, device drivers) -> hardware
layered structure(known as a loosely coupled system)把功能分成多個層，各司其職，每個層包含一個由data組成的物件以及這些資料的operations，每個層可以調用下層的service跟函數，優點是益於構建跟debug，假設某層發生error，它下面所有層都沒有bug，那bug必然發生在這layer
layered system成功應用在電腦網路(例如 TCP/IP)但很少有OS用pure layered approach，因為很難適當的定義每一層的functionality，再來就是user program要走訪好幾層才能調用system service使得performance差
microkernel起初來自卡內基美隆大學開發的"Mach" OS，以改進UNIX的程式碼越來越龐大跟難以維護的問題，它把nonessential的部件(例如app, file system, device driver等)都移到user mode，通常留下process and memory management and communication在kernel
microkernel的主要function在於提供跨程式跨服務的communication，透過message passing，user program便能interact with the file server並access a file
microkernel有利於擴展OS，不太需要修改kernel，也更容易port from one hardware design to another，甚至更secure和reliable
或許最有名的microkernel OS就是Darwin─macOS及iOS的kernel部件，Darwin有兩個主要部分，Mach microkernel以及BSD為基礎的作業系統服務和使用者空間工具
microkernel的另一個例子是QNX─a real-time OS for 嵌入式系統，它的kernel僅handle low-level network communication and hardware interrupt
microkernel的效能會隨著system-function的增加而下降，因為user-level services必須溝通，而messages得在service之間、在不同address spaces之間做copy，行程也要切來切去，Windows NT從第一代到現在也從microkernel逐漸轉換到monolithic kernel
現今OS設計最好的辦法，涵蓋了loadable kernel modules(LKMs)這樣的概念，也就是kernel包含一些關鍵的components，其餘的services藉由modules能在booting或run time link進來，每次kernel改變了就要recompile
實際上很少OS採用單一、嚴格定義的結構，它們通常結合數種結構成hybrid system，像Linux跟Windows就是既monolithic又modular
macOS跟iOS的layers：user experince layer(Aqua user interface for macOS and Springboard for touch devices)、application framework layer(Cocoa for API with Objective-C and Cocoa touch for API with Swift)、core frameworks(supoort graphics and media including, Quicktime and OpenGL)、kernel environment(Darwin <- Mach microkernel+BSD UNIX)
macOS被編譯成Intel架構能跑的，iOS kernel則針對mobile system需求，如power management and aggresive memory management，此外iOS也有比macOS更嚴格的security setting
iOS不同於macOS，它非常限制開發者，例如它限制了對POSIX和BSD APIs的存取，這些東西在macOS是available to developers
Darwin提供兩個system-call interfaces：Mach system calls(known as traps) and BSD system calls(provide POSIX)
Mach提供的services包括memory management, CPU scheduling, inter-process communication(例如message passing and remote procedure calls(RPCs))等，這些很多是available through kernel abstractions, which include tasks(a Mach process), threads, memory objects, and ports(used for IPC)
Darwin還提供一個I/O kit for device driver跟dynamically loadable modules的開發，即macOS中的kernel extensions, or kexts
Android提供豐富的frameworks來支援graphics, audio, and hardware features，這些特性反過來提供一個開發mobile app的平台
Android開發不是用標準Java API而是有自己的Android API，Java app被編譯成可以在Android RunTime(ART)上跑的格式，那ART是一種專為Android設計的VM，Java被編譯成Java bytecode .class file再轉換成.dex 可執行檔，ART實現ahead-of-time(AOT) compilation(Java的其他VM都是just-in-time JIT)，也就是我們把app安裝進裝置後ART會先把.dex檔編譯成native machine code，提升執行時的效能跟功耗
除了ART之外，開發者也能用Java的原生界面(JNI)去寫Java program，這能跳過VM直接存取特定硬體特性，但缺點就是寫出來的程式not portable from one hardware device to another，甚至更secure和reliable
Android app原生庫包括一些框架像是：web browsers(webkit), database support(SQLite), and network support, such as secure sockets(SSLs)
Google不使用Linux的標準C庫GNU C庫(glibc)而是開發了"Bionic"標準C庫 for Android，Bionic不只有比較小的memory footprint還更適用於slower CPUs
Android的軟體最底層是Linux kernel，Google對它做了各種修改以支援mobile systems的特別需要，像是power management、memory management and allocation並加入新型IPC "Binder"
Windows使用hybrid結構，提供數種subsystems來模擬不同的OS環境，像Windows 10的WSL(Windows subsystem for Linux)就是，讓native Linux app(specified as ELF bianries)能在其上執行，典型的操作是我們在bash裡開啟Linux instance(內含"init" process)，init反過來建立一個native Linux app bash(/bin/bash)之類的，這些process是在一個Windows "Pico" process裡跑，它把native Linux binary load進自己的address space然後提供一個對其相容的環境，Pico會跟kernel services LXCore和LXSS溝通來把Linux system calls轉換成Windows native ones，LXSS會把等價service做forward或幫忙做一些不equivalent的工作再把剩下的forward
generating(or building) an OS from scratch需要下列步驟：撰寫OS原始碼，根據需求來配置系統(通常是利用configuration file)，然後OS被completely compiled(known as a system build)並產生output-object version of the OS，在比較不tailored(量身訂製)的level，系統提供編譯完之object modules的選擇搭配，需要的才會被link進來，或甚至系統整個模組化，selection發生在execution time而不是compile or link time
booting步驟如下：(1)一小塊code(known as bootstrap program or boot loader) locate the kernel (2)kernel被load進memory並start (3)kernel初始化硬體 (4)root file system被mount進來
(1)boot loader，以前是BIOS，經常只是幫忙load進a second boot loader，在disk上一個位置叫boot block，這loader又把整個OS load進memory並開始執行，現今BIOS已被UEFI取代，UEFI對64位元系統和更大的硬碟支援性更好，且強大到足以做完開機到打開OS前的所有事情
GRUB是個開源的bootstrap program for Linux and UNIX，它很flexible，允許boot time下的改變，包括修改kernel參數甚至選擇kernel
mobile systems的開機流程和電腦稍微不同，例如Android的kernel雖然是Linux-based，但他不使用GRUB而是把boot loader的開發交給vendors，最常用的是"LK"(little kernel)，Android使用跟Linux相同的kernel image和最初的RAM file system，但Android不會關掉"initramfs"而是繼續用它提供的RAM file system和啟動名為"init"之process
大多OS，Windows, Linux, macOS, iOS, Android等等的boot loaders都提供開機進recovery mode or single-user mode的功能，以診斷硬體issue，修理壞掉的file system或甚至重新安裝OS
如果一個process fail了，大多OS會把error寫進log file給administrator看，它也會做core dump─對process之memory的捕捉與儲存
a failure in the kernels 叫crash，當他發生，error information被存入一個log file然後memory state存入一個crash dump
OS跟process的debugging使用的工作跟技術很不一樣，比方說kernel的file system code有錯誤時，kernel不會直接save its states to a file on the file system，而是先把memory state存到disk的一個file system以外的section，然後reboot然後a process去拿那些data並寫進crash dump file
為了做到per-process or system-wide的observations，有兩個辦法：(1)counters (2)tracing
(1)OS追蹤一系列counters，像是被呼叫的system-call數量或是對network device、disk的operation數量等，以Linux為例，per-process:"ps"─回報單一process或selection of processes的info, "top"─回報current processes的real-time statics，system-wide:"vmstat"─回報memory-usage statistics, "netstat"─回報network interfaces的statistics, "iostat"─回報disk的I/O usage
(1)大部分counter-based tools on Linux是從 "/proc" file system讀取統計，這是個 pseudo file system that only in kernel memory用來query各種per-process及kernel statistics，每個process以子目錄的型式出現在/proc下，Windows則提供Windows Task Manager(工作管理員)提供processes, CPU, memory usage, networking之統計數據
(2)以Linux為例，per-process的："strace":追蹤一process呼叫的system calls, "gdb": a source-level debugger，system-wide:"perf":一堆Linux效能工具, "tcpdump":蒐集network packets(封包)
Linux用的一個toolkit for dynamic kernel tracing是"BCC"(BPF Compiler Collection)，它是個front-end interface to the eBPF(extended Berkeley Packet Filter)，eBPF程式以C寫成，被編譯成eBPF instructions後，能被動態的插入running Linux system，它能捕捉特定事件或監控系統效能，instructions透過"verifier"pass進去，verifier會先確保instruction不會影響系統效能或security

PART TWO PROCESS MANAGEMENT
Chapter 3 Processes

早期電腦是batch system，執行jobs，後來出現time-shared system可以跑user programs, or tasks，後來single-user system讓單一使用者能同時開很多程式
process當前活動狀態的參數是program counter和處理器內的registers，process的memory layout被分成四個sections，位址低到高：(1)text section (2)data section (3)heap section (4)stack section
(1)the executable code和(2)data section的大小都是固定的
(3)這是程式在run time下能dynamically allocated的記憶體
(4)stack section也是能dynamically allocated的記憶體，像每次function被call，一內含function parameters, local variables, return address的activation record被push到stack上，當函數return時它就會被pop掉
program是passive的entity(實體)，例如存在disk內的executable file，process則是個active entity，多個processes可以是相同的program e.g. browser多開，這種情形下它們只有text section一樣，另外一process產生多processes也很常見
一個process可以是其他code的執行環境，像大部分情況下，一支Java程式會執行在Java virtual machine(JVM)中，JVM雖是個process卻能interpret load進來的Java code並藉由native machine instructions實現，例如編譯好的Java程式Program.class，我們輸入command"java Program"，java會run起JVM，JVM接著執行Program這支程式，這概念跟simulation是一樣的
process有所謂state，new:process正在被created, running:instructions被執行中, waiting:process等待some event occur(如I/O completion or reception of a signal), ready:正等待被assign進processor, terminated:process結束執行，有一點很重要就是一次只能有一個process在processor core做"running"
每個process在OS中都有一process control block或叫task control block，這裡面有：(1)process state (2)program counter (3)CPU register (4)CPU-shceduling information (5)memory-management information (6)accounting information (7)I/O status information
(1)may be new, ready, running, waiting, halted, and so on.
(2)是這process下一個instruction之address
(3)他們依CPU架構而有差異，但通常包含accumulator, index register, stack pointer, general-purpose register再加上任何condition-code information(被中斷時要存下這個)
(4)包含一個process priority, pointers to scheduling queues，以及其它的scheduling參數
(5)包含base value, limit registers, page tables or segment tables
(6)包含CPU和real-time的使用量，time limits，account numbers, job or process numbers等
(7)被分配到此process的I/O裝置列表，一個open files之list等
現在大多數OS都允許一process有多個threads，例如在文字處理器中一邊打字一邊run spell checker，這在多核心系統上非常有用，因為多個threads可以run in parallel
multiprogramming的objective(目標)是讓CPU永遠在run某些process以最大化CPU使用率，time sharing的objective是各個processes要切換得很頻繁讓user能一次跟多個program互動，這些目標仰賴process scheduler的幫忙
現在在memory的processes數量稱為degree of multiprogramming，通常process都能被分成I/O-bound(花在I/O的時間比做計算多)和CPU-bound(I/O不頻繁，做更多計算)
當一process進入系統，它們會被推進ready queue並準備好被CPU's core執行，這個queue通常以linked list儲存，ready-queue header包含head和tail兩個pointer指向first PCB和last PCB in the list，每個PCB也都帶有一pointer指向下個PCB，當執行中的process被interrupt或需要等待一特定事件的發生，諸如I/O請求的完成等，它就會被推進wait queue(此queue的構造也跟上述一樣)
當一process從ready變成running，我們說它被dispatch了，接著會有三種可能：(1)此process issue an I/O request並被放到一 I/O wait queue (2)此preocess創造一新的child process並被放到wait queue等待child's termination (3)此process被core強制移除，因為被interrupt或是發生time slice expire，並被丟回ready-queue
CPU scheduler會挑選ready queue內的一process並分配一CPU core去跑它，一I/O-bound process可能只執行幾毫秒before waiting for an I/O request，CPU-bound process會需要佔用CPU core更久但也不能太久，因此CPU scheduler每秒執行10次或更多
有些OS還有個intermediate form of scheduling叫swapping，這有利於將一process自memory暫除、寫進disk並減少degree of multiprogramming，當memory overcommited的情況消失，process可以重新寫到memory並被執行
CPU從執行process 0變成執行process 1所需經過的階段叫context switch，也就是儲存process 0的current context(registers, process state, memory-management info)並restore process 1的state，這個階段是純然的overhead，受memory speed, copy的registers數, 有無特殊instructions(例如load/store)影響，通常要數百微秒，highly dependent on hardware support
一process可以產生新的processes，創造者叫parent process，新process叫children，這樣一系列的過程形成a tree of processes
大部分OS用一unique的process identifier(pid)來標記一process，一般而言是個integer number，以Linux為例，"systemd" pid為1，是所有user processes的root parent process
傳統UNIX系統的root process是"init"(又叫 System V init), pid=1，是系統開機後第一個process，Linux最近的發行版把它改叫"systemd"並更彈性能提供更多services
一patent process生出children process有兩種執行方式：parent跟children concurretly執行 或是 parent wait 直到某些或全部children都terminate了；再來還有兩種address-space的可能：child process是parent的複製品因此program跟data會一樣，或是child被load了新的program
產生新process的舉例，一process可以fork()建立一個複製品process並return pid給變數，接著利用if else條件篩選pid是0(child process)與pid等於child process(parent process)各要做什麼事，像child可以exec()一些程式，parent也可以wait()自己的child
process可以自己exit()結束也可以被parent process給TerminateProcess() (for Windows)，通常後者有幾種原因：使用的資源量超過自己被分配到的、自己的任務對parent而言不再需要、parent正在exit()而OS不允許其child繼續跑(cascading termination現象)
正常termination下，exit()可以直接顯式的呼叫也可以被C run-time library預設性的呼叫，當一process中止，其resource會被deallocate by the OS，然而它在process table中的entry還在，要parent call wait()拿走child的exit status，parent還沒wait()前我們說child屬於zombie process
當parent process沒有 wait()就terminate，child processes就變成了orphans，傳統UNIX的處理方式是把"init" process給orphan做parent，init會週期性的invoke wait()，來蒐集orphaned processes的exit status並釋放其process identifier和process-table entry；Linux裡用"systemd"做這件事，但同時也允許systemd以外的processes去inherit(繼承) orphans
因為有限的資源，有時mobile OS會中止一些processes來得取更多資源，Android中的processes就有所謂importance hierarchy，(1)foreground process─現在螢幕上可見的process，代表user正在使用跟互動的(2)visible process─雖然前台沒有顯示，但是它在執行前台refer to的任務(3)service process─類似於background process但他執行的任務對user來說很明顯(例如直播音樂)(4)background process─執行的任務對user來說不apparent(5)empty process─這種process holds no active components associated with any application
打造一個允許process cooperation(即多個processes有share data)的環境有幾個理由：information sharing─因為多個app可能對同一塊information有興趣(例如copying and pasting)，我們必須提供環境達成concurrent access、computation speedup─為了讓一特殊任務跑得更快，我們必須把它拆成一些小任務並平行化執行、modularity─我們可能想建立一模組化的系統，把system functon拆成separate processes or threads
給processes合作跟交換data的機制叫interprocess communication(IPC)，它又分為(1)shared-memory─快速，只有一開始需要用system call來定義需要分享的memory region，之後都不用(2)message-passing─適合small amounts of data且在分散式系統中比起shared memory更容易實現
(1)複數個processes同意彼此使用相同memory，data的格式以及location是由processes決定而不受OS控制，processes們也要自己確保不會同時write一塊資料，一常見的paradigm(範例)是producer-consumer model，必須使用buffer讓producer放東西進去後再給consumer拿，它們也必須維持synchronized
(1)buffer依照size有無限制分成unbounded buffer和bounded buffer，bounded buffer的一簡單例子，item的array，用two pointer來標記能被放與能被拿的第一個位子，in==out為empty、((in+1)%BUFFER_SIZE)==out為滿，但這樣還不夠，both producer和consumer嘗試並行地access shared buffer的問題仰賴synchronization去解決
(2)此機制允許preocesses彼此溝通與synchronize它們的行動而不用share相同的address space，這在分散式系統中特別有用；messages如果是fixed-sized會有利於system-level implementation，但會導致programming更難，而variable-sized messages需要更複雜的system-level實做，但會使寫程式變單純
(2)direct communication分成symmetric和asymmetric的，前者發跟收的process要互相指定，後者只要發的人指定誰收
(2)indirect communication則是信息會被送到或取自指定的mailboxes(POSIX中以一integer來指定), or ports，processes中的發者群跟收者群共享同一mailbox時，一個link才是成立了，根據需求可以把群字改成者字，mailbox的owner就是支配mailbox的address space的process，也是receiver
message passing會是blocking(synchroous)或nonblocking(asynchronous)的：blocking send:the sending process is blocked直到message被receiving process或mailbox收走, nonblocking send:sending process寄出message並重複操作, blocking receive:收件者被block一直到有message可以取, nonblocking receive:允許receiver收到message或是null，當sender和receiver都是blocking時，我們在它們之間have a rendezvous(會面)，producer-consumer problem的解決也變簡單了
不管communicaiton是direct還是indirect，要交換的message都會存在一暫時的queue做buffer，基本上它有三種形式：(1)zero capacity:the queue的最大長度是0，換句話說link不允許任何message在裡面等，sender must block until收件者收到信，有時此法又稱為no buffering (2)bounded capacity:queue為有線長度n，因此最多n封信可reside in it，如果queue沒滿那新寄的信就會進去裡面，sender也不需要等待，當它滿時sender才會block (3)unbounded capacity:queue's length is potentially infinite，無數信可在裡面等，sender never blocks
接著介紹四種IPC：POSIX API for shared memory, message passing in Mach, Windows using shared-memory作為某種mp的機制, UNIX中最早的IPC機制之一 pipes  
POSIX shared memory:使用memory-mapped files，也就是把檔案或object投射到一塊連續記憶體上，以下是範例(1)producer (2)consumer
(1)const int SIZE=4096; const char *name="OS"; const char *message_0="Hello"; const char *message_1="World!"; fd = shm_open(name, O_CREAT | O_RDWR, 0666); ftruncate(fd, 4096);  ptr = (char *)mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); sprintf(ptr,"%s",message_1); ptr+=strlen(message_1); return 0;
(1)先用system call shm_open()去create一shared-memory object，name是object名，O_CREAT若不存在則創立，O_RDWR開起來後可讀寫，return一int當做file descriptor，ftruncate()配置ojbect size in bytes，mmap()建立一由shared-memory ojbect投影而成的memory-mapped file並return一pointer
(2)const int SIZE=4096; const char *name="OS"; int fd; char *ptr; fd=shm_open(name, O_RDONLY, 0666); ptr=(char *)mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); printf("%s", (char *)ptr); shm_unlink(name); return 0;
(2)打開"OS"這object，map到memory後印出來，再解除shared-memory segment
Mach message passing:Mach專為分散式系統設計，雖也適用於桌上和mobile，它主要使用message passing做為溝通手段，tasks(類似於processes但有多個threads與更少的關聯資源)之間使用port來收信，只有port的owner能收信和決定其他task對此port的port rights(與此port的互動能力)，然後同task的threads共用同一port right，因此同task之threads可以透過per-thread port輕鬆溝通；當一task被建立，Task Self port和Notify port也同時被建立，kernel有Task Self port的receive right，kernel也可以send 事件發生的提醒to a task's Notify port，mp主要的問題是從sender's port要copy message到receiver's port導致效能差，Mach為解決此問題不使用copy而是把address space containing sender's message into receiver's address space
mach_port_allocate()會創造一新的port和allocate queue space給他用並identify the rights for that port，每個port right代表此port的一個name，name只是個simple interger value
每一task建立自己的port後可以register with a system-wide bootstrap server，利用server上有個bootstrap port來幫大家做register，一旦註冊了，其他tasks便能在這registry中尋找此port並得到right來寄信給它
每個port之queue是finite size且一開始是空的，message遵從FIFO order進出但不遵從絕對順序，例如messages from two senders可能被以其他order編排；Mach messages有兩個fields，一fixed-size message header容納信息的metadata包括大小和source, destination等，另外還有一variable-sized body裝著data
messages可能是simple或complex的，前者代表ordinary, unstructured user data，後者包含一pointer，指向可能是大量的data(known as "out-of-line" data) 或是用來轉傳port rights給其他tasks
Mach的mp使用API "mach_msg"，我們用下面的client-server雙ports當範例：client發信:struct message {mach_msg_header_t header; int data;}; mach_port_t client;mach_port_t server; struct message message; message.header.msgh_size=sizeof(message); message.header.msgh_remote_port=server;message.header.msgh_local_port;
server收信:struct message message; mach_msg(&message.header, MACH_RCV_MSG, 0, sizeof(message), server, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
當我要寄信到port，其queue滿時我有幾種選項(透過參數告訴mach_msg)：(1)一直等到queue有空位為止 (2)等待至多 n milliseconds (3)不要等直接return (4)暫時cache this message並告訴OS去keep住，當queue空出來時OS send notification message給sender
Windows:支援所謂subsystems提供多個執行環境，apps在這些子系統間透過mp傳遞，mp facility在Windows叫advanced local procedure call(ALPC)，它跟常見的remote procedure call(RPC)很像但有經過優化，Win也是用port object來建立傳送，有兩種分別是connection ports and communication ports；
server會建立一所有processes可見的connection-port，當client想要一subsystem的服務，client發出connection request到那port，然後server建立一channel與傳回一handle，channel由一對private communication ports組成，其一for client-server messages, 另一for server-client messages，此外此channel支援call back機制允許client和server接受對方要求reply的request；
當ALPC channel被建立，下面三種mp技術會三選一 (1)for small messages(up to 256 bytes)，port的message queue被用來作intermediate storage，message從一process被copy到另一process (2)更大的message必須透過section object傳遞，這是一塊此channel專用的shared memory (3)當data量超過section object負荷的範圍，一API能用來讓server processes直接去讀寫client的address space
client發信息者若信息太大，必須請server開個section object，若server發信息太大那就自己開一section object，一夾帶section object之pointer和size info的信會由server傳給client，值得注意的是ALPC並非Windows API的一部分，所以application programmer不可能看見它，app會用Windows API呼叫standard remote procedure calls，當RPC正被同系統上一process呼叫，RPC是間接透過ALPC去handle，此外許多kernel services使用ALPC和client process溝通
UNIX pipes:以下介紹兩種在UNIX和Windows都很common的pipes類型：(1)ordinary pipes (2)named pipes
(1)UNIX範例如下：#define BUFFER_SIZE 25 #define READ_END 0 #define WRITE_END 1 int main(void){char write_msg[BUFFER_SIZE]="Greetings";char read_msg[BUFFER_SIZE];int fd[2];pid_t pid; if(pipe(fd)==-1){fprintf(stderr,"Pipe failed");return 1;} pid=fork(); if(pid<0){fprintf(stderr, "Fork Failed");return 1;} if(pid>0){close(fd[READ_END]); write(fd[WRITE_END], write_msg, strlen(write_msg)+1);close(fd[WRITE_END]);} else{close(fd[WRITE_END]);read(fd[READ_END],read_msg,BUFFER_SIZE);printf("read %s",read_msg);close(fd[READ_END]);} return 0; }
(1)pipe函數會建立一unidirectional(單向) pipe並附在file descriptor陣列上，fd[0]是read end、fd[1]是write end，parent和child各取一邊做message passing的發、收，值得注意的是他們一開始都把沒用到的pipe關掉，這重要在於確保一正在讀的process能detect end-of-file(read() returns 0)當writer關掉其end of pipe時
(1)ordinary pipes在Windows叫anonymous pipes，它們跟UNIX中的counterparts很像，單向pipe及使用ReadFile()和WriteFile()函數來讀寫，用CreatePipe()來造pipe同時傳入四個參數:parameters provide separate handles for (1)reading and (2)writing to the pipe,以及(3)an instance of the STARTUPINFO structure用來指定child可以繼承哪些pipe的handles (4)the size of the pipe(in bytes)可以指定
(1)Windows需要programmer指名child可以繼承的attributes，這可以藉由初始化SECURITY_ATTRIBUTES structure來設置可繼承項並redirect child process的handles(for std input or output) to the read or write handle of the pipe達成，child如果要read就是parent要redirect child's std input到pipe的read handle
(2)當processes結束溝通並中止，ordinary pipe就自然消失了，named pipe則提供更強大的溝通工具，bidirectional且不需要parent-child relationship，當它被建立，好幾個processes可以一起使用，通常也有好幾個writers，此外當communicating processes finish時named pipes仍會存在
(2)UNIX中named pipes被作為FIFO並且像一般file一樣被使用，被mkfifo()創造後，就能被open(), read(), write(), close()等，直到有人explicitly delete它；此pipe允許雙向溝通，可以half-duplex(半雙工，資料可雙向傳遞但不能同時進行)，可以同machine下溝通(intermachine要靠socket)
(2)Windows系統提供更強大的named pipes，可full-duplex，可跨機器，不只辦到UNIX中的byte-oriented data傳送，還能傳送message-oriented data，用CreateNamedPipe()建立以及ConnectNamedPipe()連接，用ReadFile(), WriteFile()溝通
最後是兩種client-server systems的通訊策略，(1)sockets (2)remote procedure calls(RPCs)
(1)socket是network通訊的endpoint的稱呼，processes利用一對sockets來連線，socket使用IP address來辨識，並concatenate with 一個 port number，基本上sockets採用client-server架構，server聽取、接收client的request並實作(SSH, FTP, HTTP)等service，並聽well-known ports(SSH:22, FTP:21, HTTP:80)，當一host X上之client(IP:146.86.5.20)連上伺服器(IP:161.25.19.8)，client之host computer會給自己一port，變成一對sockets在通訊(如146.86.5.20:1625 vs 161.25.19.8:80)，每個connection都是獨立的，因此其它host X上的process要連到這個web server的話，這process會被assign另一個大於1024且不等於1625的port number
(1)Java提供三種sockets:connection-oriented(TCP) sockets使用"Socket" class實做、connectionless(UDP) sockets使用"DatagramSocket" class、"MulticastSocket" class為DatagramSocket之subclass它是multicast socket允許data傳送到多個recipients
(1)connection-oriented TCP sockets的server範例如下：ServerSocket(6013)指定server聽6013的port，並使用accept()持續聽，直到有client連進來，會return一socket給server用來通訊，建立一PrintWriter object來write to the socket(using the routine print() and println() for output)，寫完後close這socket再重新listen for more requests
(1)client範例如下：client creates a "Socket"並向server 127.0.0.1:6013請求連線，一旦連上，client可以從socket讀信息，接收到後關閉socket並exit，127.0.0.1是個特別的IP known as the loopback，當一電腦參照此IP時，它參照的是它自己，這允許client and server on the same host用TCP/IP protocol做溝通，當然此IP也可以換成another host跑著server的IP
(1)使用sockets的通訊雖然普遍而有效率，但算是比較低階，它只允許unstructured stream of bytes to be exchanged，imposing a structure on the data是client or server app的責任
(2)remote service中最普遍的一種─RPC paradigm，設計來抽象化procedure-call機制和系統間網路連接使用，跟IPC相反，信息是well structured不再只是一包資料，每個信息被傳到remote系統上一聽著一個port的RPC daemon，信息裡指定需要的function去執行並傳回另一封output
(2)一系統正常是一network address，但可以有多ports within that addresse來劃分眾多network services，舉例來說若一系統要能讓其他系統列出自己當前user，此系統可能用一daemon來支持這樣的RPC附加在某port上──say, port 3027，任何remote system可以發RPC信息到此port來得取reply
(2)RPC系統靠著在client side提供一個stub(樁)來隱藏通訊細節，一般每個remote procedure一個stub，當client invoke一個remote procedure，RPC call適合的stub代入remote procedure，這stub定位server上的port並marshal(編組)參數，那stub接著利用mp傳送信息到server，一server side上之相似stub接收並invoke the procedure；在Windows系統上，stub code被編譯自一特殊規格──Microsoft Interface Definition Language(MIDL)(用來定義client和server programs之間的界面)
(2)parameter marshaling解決了client和server machines之data表達不一樣的問題，例如有些系統是big-endian有些是little-endian，為解決像這樣的問題，很多RPC系統採用與machine無關的data representation，其中一種representation是external data representation(XDR)，client先把本地資料轉成XRD再傳到server，server收到data後做unmarshal並轉成machine-dependent representation
(2)另外一個重要的issue在於call的semantics，RPCs因為common network errors導致它有時可以fail或是被複製並執行超過一次，解決方法是OS要確保messages被執行exactly once(非at most once)，後者只要在message加個time stamp，後到且重複的就不做，前者基於後者之上再加上server服務完須回報ACK(acknowledge) messages代表收到並執行，否則client應當週期性的resend each RPC call
(2)最後一個重要issue是RPC scheme需要像standard procedure calls一樣在client和server間建立binding，standard procedure call's name被memory address of the procedure call取代，RPC則要做到client port bind server port，兩種解法，一是binding info先決定好 in the form of fixed port address，在編譯期 an RPC call有一跟它相關的fixed port number，一旦program編譯好server就不能改服務的port number，二是由OS提供rendezvous(matchmaker) daemon on a fixed RPC port，client發信請求rendezvous提供能執行此RPC的port address，client再發RPC call到那個port，此法會有overhead(兩次request)但更彈性
RPCs雖然一般跟分散式系統中client-server運算有關，Android "Binder"框架將RPCs融入其IPC機制中，Android定義"application component"為application的基本組件，每個application component就是個service，沒有UI但是背景執行，例如process1背景播放音樂時process2接收網路data，它阻止process1被block，當一client app invoke 某服務之bindService()服務便被bound同時使用mp or RPCs提供client-server通訊
一bound service必須extend Android class "Service"與實作method "onBind()"，此method在client call bindService()時會被invoke，以mp來說，onBind() return一"Messenger"service以讓client發信給service，它是one-way的，如果service也想發信回client，client必須也提供Massenger服務(contained in the "replyTo" field of the "Message" object)
要提供RPCs，onBind()方法必須return一interface代表remote object裡的method給client跟他互動用，這interface以Java常規語法寫成並使用Android Interface Definition Language──AIDL來創造stub files